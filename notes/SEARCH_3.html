<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8" />
<meta name="generator" content="quarto-1.7.32" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

<meta name="author" content="Harrison Youn Search and Matching 3" />
<meta name="dcterms.date" content="2025-08-10" />
<meta name="description" content="How can we measure sorting when theory tells us wages are complex and data is messy?" />

<title>Finding the Signal in the Noise ‚Äì Harrison Youn | Website</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>

<!-- htmldependencies:E3FAD763 -->
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Person",
  "name": "Harrison Yongjoon Youn",
  "url": "https://www.harrisonyoun.com",
  "image": "https://www.harrisonyoun.com/assets/avatar.png",
  "jobTitle": "Economics PhD Candidate",
  "worksFor": {
    "@type": "Organization",
    "name": "The Ohio State University"
  },
  "sameAs": [
    "https://scholar.google.com/citations?hl=en&user=GyMw0H0AAAAJ",
    "https://github.com/harrisonyoun",
    "https://www.linkedin.com/in/harrison-youn/",
    "https://x.com/YongjoonYoun"
  ]
}
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Lora:wght@400;700&family=Inter:wght@700&family=Roboto+Condensed:wght@400&display=swap" rel="stylesheet">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Harrison Yongjoon Youn - Economics PhD Candidate at The Ohio State University">
<meta name="keywords" content="Labor Economics, Health Economics, AI, Science and Innovation">
<meta name="author" content="Harrison Yongjoon Youn">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css" />
</head>

<body>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="/index.html">
    <span class="navbar-title">Harrison Youn</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
  aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation"
  onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="/assets/CV.pdf"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="/research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="/notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <div id="quarto-toc-target"></div>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Finding the Signal in the Noise</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Labor Economics</div>
    <div class="quarto-category">Search and Matching</div>
    <div class="quarto-category">AKM Model</div>
    <div class="quarto-category">Econometrics</div>
  </div>
  </div>

<div>
  <div class="description">
    How can we measure sorting when theory tells us wages are complex and data is messy?
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Harrison Youn<br><span style="font-size: 0.8em; color: #6c757d;">Search and Matching 3</span> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 10, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-theoretical-challenge-and-real-data" id="toc-the-theoretical-challenge-and-real-data">The Theoretical Challenge and Real Data</a></li>
  <li><a href="#the-clash-with-the-akm-model-when-two-worlds-collide" id="toc-the-clash-with-the-akm-model-when-two-worlds-collide">The Clash with the AKM Model: When Two Worlds Collide</a></li>
  <li><a href="#empirical-strategies-how-to-detect-the-signal" id="toc-empirical-strategies-how-to-detect-the-signal">Empirical Strategies: How to Detect the Signal</a></li>
  <li><a href="#conclusion-the-economist-as-a-detective" id="toc-conclusion-the-economist-as-a-detective">Conclusion: The Economist as a Detective</a></li>
  <li><a href="#references" id="toc-references">References</a></li>
  </ul>
</nav>
<section id="the-theoretical-challenge-and-real-data" class="level2">
<h2>The Theoretical Challenge and Real Data</h2>
<p>In our journey so far, we‚Äôve traveled from two different worlds. In <strong>Part 1</strong>, we explored Becker‚Äôs frictionless paradise, where the market, like an omniscient matchmaker, paired agents perfectly, and positive sorting was the natural outcome of simple complementarity (<span class="math inline">\(f_{xy}&gt;0\)</span>).</p>
<p>In <strong>Part 2</strong>, we plunged into the messy, frictional world of Shimer and Smith. There, the ‚Äúprice of the search‚Äù complicated everything. We discovered that wages were no longer a simple sum but a complex bargain reflecting outside options and match-specific output. More importantly, we learned that for orderly sorting (PAM) to survive the temptations of strategic waiting, a much stronger condition, log-supermodularity, was required. Theory, in short, predicts <strong>complexity</strong>.</p>
<p>And yet, the most popular tool in empirical labor economics, the AKM model, assumes elegant <strong>simplicity</strong>: <span class="math inline">\(w_{it} = \alpha_i + \psi_{j(i,t)} + \varepsilon_{it}\)</span>. How do we bridge this chasm between a complex theory and a simple empirical framework?</p>
<hr />
</section>
<section id="the-clash-with-the-akm-model-when-two-worlds-collide" class="level2">
<h2>The Clash with the AKM Model: When Two Worlds Collide</h2>
<p>The search-and-matching theory and the AKM model are built on fundamentally different philosophies. Their collision reveals the core challenges of empirical work in this field.</p>
<section id="the-problem-of-non-additive-wages" class="level4">
<h4>The Problem of Non-Additive Wages</h4>
<p>As we derived in Part 2, a bargained wage in a search model often looks like: <span class="math display">\[
w(x,y) = (1-\alpha)rW_0(x) + \alpha f(x,y) - \alpha r\Pi_0(y)
\]</span> The term <strong><span class="math inline">\(\alpha f(x,y)\)</span></strong> is the smoking gun. It inextricably links the worker‚Äôs type (<span class="math inline">\(x\)</span>) and the firm‚Äôs type (<span class="math inline">\(y\)</span>).</p>
<p><strong>Implication:</strong> If this theory is correct, then estimating a standard AKM model is an act of <strong>misspecification</strong>. AKM forces reality into an additive box. But what happens to the interaction term? It gets shoved into the residual, <span class="math inline">\(\varepsilon_{it}\)</span>. This isn‚Äôt just a minor issue; it violates the core assumption that the error term is random noise, uncorrelated with the regressors.</p>
<blockquote>
<p><strong>Example:</strong> Imagine a simple multiplicative production function, <span class="math inline">\(f(x,y) = x \cdot y\)</span>, where this complementarity is stark. The wage will contain a term like <span class="math inline">\(\alpha xy\)</span>. When you force an additive model (<span class="math inline">\(w \approx \alpha_i + \psi_j\)</span>) onto this reality, the model does its best to find average effects. But the errors will be systematic: For a high-skill worker at a high-productivity firm (high <span class="math inline">\(x\)</span>, high <span class="math inline">\(y\)</span>), the true wage is very high. The additive model will <em>under-predict</em> their wage, leaving a <strong>large, positive residual</strong>. For a low-skill worker at a high-productivity firm (low <span class="math inline">\(x\)</span>, high <span class="math inline">\(y\)</span>), the true wage is modest. The additive model might <em>over-predict</em> it, leaving a <strong>negative residual</strong>.</p>
<p>Because the error is predictable based on the types of the worker and firm, the estimated effects, <span class="math inline">\(\hat{\alpha}_i\)</span> and <span class="math inline">\(\hat{\psi}_j\)</span>, will be biased. The model systematically fails to capture the explosive potential of high-high matches, which is the very essence of positive sorting.</p>
</blockquote>
</section>
<section id="the-identification-failure-under-pure-pam" class="level4">
<h4>The Identification Failure under Pure PAM</h4>
<p>An even more fundamental problem arises if sorting is perfect.</p>
<p><strong>Connected Sets:</strong> For AKM to statistically separate <span class="math inline">\(\alpha_i\)</span> from <span class="math inline">\(\psi_j\)</span>, it needs to observe the same worker <span class="math inline">\(i\)</span> at different firms, say <span class="math inline">\(j\)</span> and <span class="math inline">\(k\)</span>. The wage change upon moving, <span class="math inline">\(w_{ik} - w_{ij}\)</span>, allows the model to estimate the firm premium difference, <span class="math inline">\(\psi_k - \psi_j\)</span>, since the worker‚Äôs own effect <span class="math inline">\(\alpha_i\)</span> is held constant. The network of firms linked by these ‚Äòmover‚Äô workers is called a <strong>connected set</strong>.</p>
<blockquote>
<p><strong>Intuitive Analogy: The Mystery of the Isolated Islands</strong> üèùÔ∏è</p>
<p>Imagine the labor market consists of two isolated islands: ‚ÄòHigh-Tech Island‚Äô and ‚ÄòFactory Island.‚Äô High-tech workers only work on their island, and manufacturing workers only work on theirs. <strong>No ferry runs between them.</strong> We observe that wages are much higher on High-Tech Island. But we have no way of knowing if this is because the <strong>people (<span class="math inline">\(\alpha_i\)</span>)</strong> on High-Tech Island are brilliant or because the <strong>environment (<span class="math inline">\(\psi_j\)</span>)</strong> of the island itself is productive. The two effects are perfectly confounded. If just one person were to take a ferry and work on the other island, they would provide a crucial reference point‚Äîa ‚Äòcontrol‚Äô subject‚Äîto solve the mystery.</p>
<p><strong>Perfect PAM is this ‚Äòno ferry‚Äô state.</strong> The labor market stratifies into disconnected segments. From a statistical standpoint, this means the design matrix of the regression is block-diagonal. You can identify firm effects <em>within</em> an island, but you can‚Äôt compare the general pay level of High-Tech Island to Factory Island. You could add $1,000,000 to every firm effect on High-Tech Island and subtract it from every worker effect there, and the predicted wages would be identical. Identification fails.</p>
</blockquote>
<p>Fortunately, in reality, sorting is imperfect. Frictions ensure some workers take the ‚Äúferry,‚Äù creating a large connected set. But if sorting is strong, these ferry routes between very different island types can be rare, making our estimates less precise.</p>
<hr />
</section>
</section>
<section id="empirical-strategies-how-to-detect-the-signal" class="level2">
<h2>Empirical Strategies: How to Detect the Signal</h2>
<p>Given these challenges, how can we find evidence for sorting? Economists have developed several clever, indirect strategies.</p>
<section id="the-hlm-rank-method-a-logic-puzzle" class="level4">
<h4>1. The HLM Rank Method: A Logic Puzzle</h4>
<p>Hagedorn, Law, and Manovskii (2017) propose a non-parametric method that treats the problem like a logic puzzle, teasing out the underlying ranks of workers and firms.</p>
<ol type="1">
<li><strong>Rank Workers Within Firms:</strong> The starting premise is simple: within a single firm, wages should be monotonic in ability. The highest-paid person is likely the most skilled one there. This gives us a <em>relative</em> ranking within each company.</li>
<li><strong>Link Ranks Across Firms via Movers:</strong> This is the key step to create a <em>global</em> ranking. The logic is transitive:
<ul>
<li><code>IF (Alice's salary &gt; Bob's salary) @ Google,</code></li>
<li><code>AND Bob moves to Meta, WHERE (Bob's salary &gt; Carol's salary),</code></li>
<li><code>THEN we infer the global rank: Alice &gt; Bob &gt; Carol.</code> By chaining together tens of thousands of such moves in large datasets, the HLM algorithm constructs a comprehensive ability ranking for millions of workers.</li>
</ul></li>
<li><strong>Rank Firms by Productivity:</strong> With a global ranking of workers, we can now rank firms. A better firm should pay more for a worker of a given skill level. HLM effectively asks: ‚ÄúFor a worker in the 70th percentile of ability, which firms pay the most?‚Äù This provides a productivity ranking of firms.</li>
<li><strong>Recover the Production Function:</strong> Once you have ranks for workers (<span class="math inline">\(x\)</span>) and firms (<span class="math inline">\(y\)</span>), you can visualize the ‚Äúwage surface‚Äù over the <span class="math inline">\((x,y)\)</span> plane. The <em>curvature</em> of this surface reveals complementarity. If it‚Äôs just two intersecting planes, the world is additive. If it curves upward (like a Pringle‚Äôs chip), so that the wage increase from moving up the firm ladder is greater for high-ranked workers, that‚Äôs the signature of <span class="math inline">\(f_{xy}&gt;0\)</span>. HLM‚Äôs contribution is showing how to do this without assuming a specific functional form for <span class="math inline">\(f(x,y)\)</span>.</li>
</ol>
<p><strong>Limitation:</strong> This method‚Äôs core assumption‚Äîthat wages within a firm reflect static ability‚Äîis challenged by the On-the-Job Search models we will discuss in Part 4, where wages can grow over time due to outside offers.</p>
</section>
<section id="poaching-flows-and-revealed-preference-a-popularity-contest" class="level4">
<h4>2. Poaching Flows and Revealed Preference: A Popularity Contest</h4>
<p>Sorkin (2018) and others use a different approach: ignore wages for a moment and focus on <strong>actions</strong>. Where do workers choose to go?</p>
<blockquote>
<p><strong>Intuitive Analogy: Voting with Your Feet</strong> üó≥Ô∏è</p>
<p>If students from University A are all trying to transfer to University B, but no one from B is trying to transfer to A, we infer that B is the ‚Äúbetter‚Äù university. The logic of revealed preference is that workers ‚Äúvote with their feet,‚Äù and these flows reveal the underlying hierarchy of the market.</p>
</blockquote>
<p>This method is powerful because it‚Äôs less contaminated by firm-specific pay-setting policies or bargaining frictions. It creates a directed graph of the labor market based on net poaching flows. The ranking algorithm, which is conceptually similar to Google‚Äôs PageRank, then finds the firm ranking that is most consistent with the observed ‚Äúuphill‚Äù flow of workers.</p>
</section>
<section id="boundary-monotonicity-tests-the-velvet-rope-policy" class="level4">
<h4>3. Boundary Monotonicity Tests: The Velvet Rope Policy</h4>
<p>A sharp prediction of PAM is that there should be an ‚Äúability floor‚Äù for top firms.</p>
<blockquote>
<p><strong>Intuitive Analogy: The Implicit Entry Requirement</strong> ‚õî</p>
<p>A five-star restaurant has a dress code; a top-tier firm has an implicit ‚Äòability code‚Äô. You don‚Äôt expect to find a worker from the bottom 10% of the national skill distribution working as a quantum physicist at Google. The firm‚Äôs ‚Äúvelvet rope‚Äù policy simply wouldn‚Äôt allow them in.</p>
</blockquote>
<p>This implies that the <em>distribution</em> of worker abilities should be different at different firm tiers. Empirically, we can test this: 1. Rank firms into tiers (e.g., by average wage paid). 2. For each tier, plot the cumulative distribution function (CDF) of their workers‚Äô abilities (proxied by <span class="math inline">\(\hat{\alpha}_i\)</span>). 3. Under PAM, the CDF for a high-tier firm group must lie entirely to the right of the CDF for a low-tier group. This property is called <strong>first-order stochastic dominance</strong>. It‚Äôs a strong, testable prediction that the entire quality distribution shifts upward at better firms.</p>
<hr />
</section>
</section>
<section id="conclusion-the-economist-as-a-detective" class="level2">
<h2>Conclusion: The Economist as a Detective</h2>
<p>The journey from the clean theory of Part 1 to the frictional theory of Part 2 left us with a puzzle: our models predict a complex reality, but our main empirical tool, AKM, assumes a simple one. This chapter has shown how economists, acting as detectives, have developed sophisticated tools to resolve this tension.</p>
<p>By using the logic of relative rankings (HLM), observing the market‚Äôs ‚Äúvotes‚Äù (Sorkin), and checking the ‚Äúentry requirements‚Äù at top firms (Boundary Monotonicity), they can find the signal of sorting amidst the noise. These methods confirm that the complex interactions predicted by theory are not just mathematical curiosities; they are essential features of the real labor market that shape productivity, mobility, and inequality.</p>
<hr />
</section>
<section id="references" class="level2">
<h2>References</h2>
<p>Hagedorn, M., Law, K., &amp; Manovskii, I. (2017). Identifying equilibrium models of sorting. <em>Econometrica, 85</em>(1), 29-65.</p>
<p>Sorkin, I. (2018). Ranking firms using revealed preference. <em>The Quarterly Journal of Economics, 133</em>(1), 353-401.</p>
<div id="quarto-navigation-envelope" class="hidden">
<p><span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyLXRpdGxl">Harrison Youn | Website</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uYXZiYXItdGl0bGU=">Harrison Youn</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uYXZiYXI6Q1Y=">CV</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uYXZiYXI6L2Fzc2V0cy9DVi5wZGY=">/assets/CV.pdf</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uYXZiYXI6UmVzZWFyY2g=">Research</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uYXZiYXI6L3Jlc2VhcmNoLmh0bWw=">/research.html</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uYXZiYXI6Tm90ZXM=">Notes</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uYXZiYXI6L25vdGVzLmh0bWw=">/notes.html</span></p>
<div class="hidden quarto-markdown-envelope-contents" data-render-id="Zm9vdGVyLWxlZnQ=">
<p>¬© 2025 Harrison Yongjoon Youn</p>
</div>
</div>
<div id="quarto-meta-markdown" class="hidden">
<p><span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLW1ldGF0aXRsZQ==">Finding the Signal in the Noise ‚Äì Harrison Youn | Website</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLXR3aXR0ZXJjYXJkdGl0bGU=">Finding the Signal in the Noise ‚Äì Harrison Youn | Website</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLW9nY2FyZHRpdGxl">Finding the Signal in the Noise ‚Äì Harrison Youn | Website</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLW1ldGFzaXRlbmFtZQ==">Harrison Youn | Website</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLXR3aXR0ZXJjYXJkZGVzYw==">How can we measure sorting when theory tells us wages are complex and data is messy?</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLW9nY2FyZGRkZXNj">How can we measure sorting when theory tells us wages are complex and data is messy?</span></p>
</div>
</section>

</main> <!-- /main -->
<script id = "quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.harrisonyoun\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <div class='footer-contents'>¬© 2025 Harrison Yongjoon Youn</div>  
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>

</body>

</html>
